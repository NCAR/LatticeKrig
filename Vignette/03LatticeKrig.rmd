# Sample \ttt{LatticeKrig} calculation

The computations inside of \ttt{LatticeKrig} and \ttt{LKrig} can be hard to understand, so here we will work through the 1 dimensional example in the quick start guide, showing all of the linear algebra used. Some of the variable names will be changed from the code in the previous section so that they match the names in the linear algebra appendix.

```{r CalculationsSetup}
set.seed(223)

lambda = kFit1D$LKinfo$lambda
rho = kFit1D$rho.MLE
phi <- function(d) {
  return(1/3 * (1-d)^6 * (35*d^2 + 18*d + 3) * (d < 1))
}
overlap = 2.5

x <- runif(50, min=-6, max=6)
y <- sin(locations) + rnorm(50, sd = 1e-2)
dx <- dist(x)
```



## Making the Lattice

In the example, we have \ttt{NC = 7} lattice points in the interval at the highest level, with \ttt{NC.buffer} = 5 lattice points over each edge of the interval. 

```{r CalculationsLattice}
nc = 7
ncBuffer = 5
xMin = min(x)
xMax = max(x)
xRange = xMax - xMin

LGap = xRange / (nc-1)
L1Inside = seq(xMin, xMax, LGap)
L1Before = (-5:-1)*LGap + xMin
L1After = (1:5)*LGap + xMax
L1 = c(L1Before, L1Inside, L1After)

L2Inside = seq(xMin, xMax, LGap/2)
L2Before = (-5:-1)*(LGap/2) + xMin
L2After = (1:5)*(LGap/2) + xMax
L2 = c(L2Before, L2Inside, L2After)

L3Inside = seq(xMin, xMax, LGap/4)
L3Before = (-5:-1)*(LGap/4) + xMin
L3After = (1:5)*(LGap/4) + xMax
L3 = c(L3Before, L3Inside, L3After)

s1 = length(L1)
s2 = length(L2)
s3 = length(L3)
```

## Creating the Covariance Matrices $P$ and $M_\lambda$

```{r CalculationsCovariance}
tridiag <- function(entries, size) {
  mat <- diag(entries[2], size)
  mat[col(mat) - row(mat) == -1] = entries[1]
  mat[col(mat) - row(mat) == 1] = entries[3]
  return(mat)
}

alpha <- c(16, 4, 1)/21
Phi1 <- phi(rdist(x, L1) / (overlap*LGap))
Phi2 <- phi(rdist(x, L2) / (overlap*LGap/2))
Phi3 <- phi(rdist(x, L3) / (overlap*LGap/4))
Phi <- cbind(Phi1, Phi2, Phi3)

B1 <- tridiag(c(-1, 2.01, -1), s1)
B2 <- tridiag(c(-1, 2.01, -1), s2)
B3 <- tridiag(c(-1, 2.01, -1), s3)
Q1 <- t(B1) %*% B1
Q2 <- t(B2) %*% B2
Q3 <- t(B3) %*% B3
Q <- matrix(0, nrow = s1+s2+s3, ncol = s1+s2+s3)

#putting Q1, Q2, Q3 into block-diagonal matrix Q
Q[1:s1, 1:s1] <- Q1
Q[(s1+1):(s1+s2), (s1+1):(s1+s2)] <- Q2
Q[(s1+s2+1):(s1+s2+s3), (s1+s2+1):(s1+s2+s3)] <- Q3
#P = solve(Q)
M <- t(Phi)  %*% Phi + lambda*Q
```

## Finding the Fixed Component

```{r CalculationsFixed}
ones <- rep(1, length(x))
Z <- cbind(ones, x)
M <- Phi %*% P %*% t(Phi) + lambda*diag(1, length(x))
d <- solve(t(Z) %*% solve(M) %*% Z) %*% t(Z) %*% solve(M) %*% y
test.for.zero(d, kFit1D$d.coef)
```