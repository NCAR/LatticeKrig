LKDist.R:        cat("temp space set at", Nmax, fill = TRUE)
LKDistComponents.R:        cat("temp space set at", Nmax, fill = TRUE)
LKinfoUpdate.R:      cat(    "No match in current LKinfo for these new argument(s) ",
LKrig.MLE.R:      	cat("LKrig.MLE: initial LKinfo object:", fill=TRUE)
LKrig.MLE.R:          	cat("LKrig.MLE: find lambda grid value", k,  fill=TRUE)
LKrig.R:		cat(" ", fill=TRUE)
LKrig.R:		cat("LKrig: updated LKinfo object", fill=TRUE)
LKrig.R:  cat("LKrig: Nonzero entries in Q:", length(Q@entries), fill=TRUE)		
LKrig.R:	    cat("LKrig: Nonzero entries in M:", length(G@entries), fill=TRUE)	
LKrig.R:	    cat( "Dense matrix methods used", fill=TRUE)
LKrig.R:     	cat("LKrig: nonzero entries of GCholesky:",nonzero.entries, fill=TRUE)
LKrig.R:		cat("Likelihood/MLE list:",  fill=TRUE)
LKrig.basis.R:          cat("LKrig.basis: Dim x1 ",  dim( x1), fill=TRUE)
LKrig.basis.R:          cat(" Dim PHI level", l, dim( PHItemp), fill=TRUE)
LKrig.basis.R:          cat("time for basis", fill=TRUE) 
LKrig.basis.R:            		cat("time for normalization", "fast=", fast,  fill=TRUE)
LKrig.basis.R:          cat("normalized basis functions", fill=TRUE)
LKrig.coef.R:    	cat("d.coef: ", d.coef, fill=TRUE)
LKrig.coef.R:    	cat( fill=TRUE)
LKrig.coef.R:    	cat("c.coef: ", c.coef, fill=TRUE)
LKrig.make.par.grid.R:      cat(N)
LKrig.precision.R:            	cat("dim indices in spind of B:",dim( tempB$ind) , fill=TRUE)            	
LKrig.precision.R:                cat("length alpha parameter", length( alpha.level), fill=TRUE)
LKrig.precision.R:              cat("alpha at each level can only be a scalar \n
LKrig.precision.R:        	cat("dim of ind (fullB):", dim( ind), fill=TRUE)
LKrig.precision.R:        	cat("dim after spind to spam in precision:", dim( tempB), fill=TRUE)
LKrig.sim.conditional.R:    	cat("LKrig.sim.conditional: x.grid")
LKrig.sim.conditional.R:    	cat("LKrig.sim.conditional: dim(PHIGrid)",  dim(PHIGrid), fill=TRUE)
LKrig.sim.conditional.R:        cat(k, " ")
LKrig.spind2spam.R:            cat(N.missing, " missing row(s)", fill = TRUE)
LKrigFindLambda.R:    	cat( "LKrigFindLambda: Complete set of LKrigArgs:", names(LKrigArgs ), fill=TRUE)
LKrigFindLambda.R:    	cat("LKrigFindLambda: llambda.start:",  llambda.start, fill=TRUE)
LKrigFindLambda.R:#    cat("temp.fn: lambda ", exp(x), fill=TRUE)
LKrigFindLambda.R:            	cat("Results from optimize:", fill=TRUE)
LKrigFindLambdaAwght.R:    cat( "LKrigFindLambdaAwght: Set of LKrigArgs before first call:", names(LKrigArgs ), fill=TRUE)
LKrigFindLambdaAwght.R:    cat("LKrigFindLambdaAwght: llambda.start:",  llambda.start, "a.wght.start:", Awght.init, fill=TRUE)
LKrigFindLambdaAwght.R:    cat("Capture.evaluations first call", fill=TRUE )
LKrigFindLambdaAwght.R:    cat("lambda", "log lambda", "a.wght", "omega",
LKrigFindLambdaAwght.R:    cat( capture.evaluations, fill=TRUE)
LKrigFindLambdaAwght.R:      cat("Results from optimize:", fill=TRUE)
LKrigFindLambdaAwght.R:    cat( rowForCapture, fill=TRUE )
LKrigMakewU.R:    cat("dim wU:", dim(wU),  fill=TRUE)
LKrigMakewX.R:	cat( "LKrigMakewX: dim X ", dim( object$X), fill=TRUE)	
LKrigMakewX.R:	cat( "LKrigMakewX: dim wX ", dim( wX), fill=TRUE)	
LKrigMarginalVariance.R:          cat("LKrig.basis: Dim x1 ",  dim( x1), fill=TRUE)
LKrigSetup.R:    	cat("----- After call to setDefaultsLKinfo -----", fill=TRUE)
LatticeKrig.R:              cat("extra args:", fill=TRUE)
ModelRectangle.R:		cat("ranges of transformed variables", range.x, fill = TRUE)
ModelRectangle.R:#	  cat("turn off fast normalization")
ModelRectangle.R:        #cat("adjusted SAR boundaries")
Radial.basis.R:        cat('Radial.basis Nmax',         Nmax       , fill=TRUE)
Radial.basis.R:    	cat('Radial.basis basis.delta' , basis.delta, fill=TRUE)
Radial.basis.R:    	cat("time for LKDistance")
createLKrigObject.R:	#cat("createLKrigObject: inverseModel", inverseModel, fill=TRUE)
predictLKrigFixedFunction.R:#    cat( "predictLKrigFixedFunction:  ind.drift", ind.drift, fill=TRUE)
predictLKrigFixedFunction.R:#     cat( "predictLKrigFixedFunction:  dim(T.matrix)", dim(T.matrix), fill=TRUE)                              
print.LKinfo.R:    cat("Classes for this object are: " , class( LKinfo), fill=TRUE)
print.LKinfo.R:    cat("The second class usually will indicate the geometry
print.LKinfo.R:    cat(" ", fill = TRUE) 
print.LKinfo.R:      cat("Hey, the dense flag is TRUE so computations will
print.LKinfo.R:    cat("Ranges of locations in raw scale:", fill=TRUE)
print.LKinfo.R:    	cat("(inverse) linear transformation for lattice nodes:",fill=TRUE)
print.LKinfo.R:    	cat("transformed ranges:",fill=TRUE)
print.LKinfo.R:    cat(" ", fill = TRUE)
print.LKinfo.R:    cat("Logical (collapseFixedEffect) if fixed effects will be pooled:" ,
print.LKinfo.R:    cat(" ", fill = TRUE)
print.LKinfo.R:    cat("Number of levels:", L, fill = TRUE)
print.LKinfo.R:    cat("delta scalings:", x$latticeInfo$delta, fill = TRUE)
print.LKinfo.R:    cat("with an overlap parameter of ", LKinfo$basisInfo$overlap, fill=TRUE)
print.LKinfo.R:    cat("alpha: ", unlist(x$alpha), fill = TRUE)
print.LKinfo.R:        cat("based on smoothness nu = ", x$nu, fill = TRUE)
print.LKinfo.R:      cat("alpha specified at each level by objects: ",fill=TRUE)
print.LKinfo.R:      cat("Level ", "Class", fill=TRUE)
print.LKinfo.R:               cat( level, class(x$alphaObject[[1]]), fill=TRUE )
print.LKinfo.R:    cat(" ", fill = TRUE)
print.LKinfo.R:    cat("a.wght: ", temp, fill = TRUE)
print.LKinfo.R:      cat("dim(A.wght[[k]]): ",
print.LKinfo.R:      cat(" Level", k,
print.LKinfo.R:      cat("a.wght specified at each level by objects: ",fill=TRUE)
print.LKinfo.R:      cat("Level ", "Class", fill=TRUE)
print.LKinfo.R:        cat( level, class(x$a.wghtObject[[1]]), fill=TRUE )
print.LKinfo.R:       cat(" ", fill = TRUE)
print.LKinfo.R:      cat( "Basis  type:",
print.LKinfo.R:  cat("Basis functions will be normalized", fill=TRUE)
print.LKinfo.R:  cat(" ", fill = TRUE)      
print.LKinfo.R:  cat("Total number of basis functions ",  LKinfo$latticeInfo$m, fill=TRUE)  
print.LKinfo.R:        cat(" ", fill = TRUE)  
print.LKinfo.R: cat("Lambda value: ", LKinfo$lambda, fill=TRUE)         
print.LKrig.R:#    cat("Call:\n")
print.LKrig.R:    	 cat("NOTE: This is an 'inverse' model because U and  X matrices are supplied", fill=TRUE)}
print.LKrig.R:    cat(" ", fill = TRUE)
print.LKrig.R:      cat(" ", fill = TRUE)
print.LKrig.R:        cat("Estimated fixed effects pooled across
print.LKrig.R:        cat("Estimated fixed effects found separately
print.LKrig.R:      cat("collapseFixedEffect :", x$collapseFixedEffect, fill=TRUE)
print.LKrig.R:      cat("Note: MLEs are the combined estimates across replicates.",
print.LKrig.R:        cat("No fixed part of model", fill = TRUE)
print.LKrig.R:            cat("Fixed part of model is a polynomial of degree",
print.LKrig.R:          cat("Fixed part of model uses the function:",
print.LKrig.R:          cat("with the argument list:", fill = TRUE)
print.LKrig.R:    cat("Basis function type: ", LKinfo$basisInfo$BasisType, 
print.LKrig.R:    cat("Basis function used: ", LKinfo$basisInfo$BasisFunction, 
print.LKrig.R:    cat(" ", fill = TRUE)
print.LKrig.R:      cat( LKinfo$nlevel, " Levels" ,  LKinfo$latticeInfo$m, "total basis functions", 
print.LKrig.R:    cat(" ", fill = TRUE)
print.LKrig.R:    cat("Type of distance metric used: ", LKinfo$distance.type, 
print.LKrig.R:    cat(" ", fill = TRUE)
print.LKrig.R:        cat("Value(s) for weighting (alpha parameters): ",
print.LKrig.R:        cat("alpha values passed as a vector for each level", 
print.LKrig.R:    cat(" ", fill = TRUE)
print.LKrig.R:        cat("Value(s) for lattice dependence (a.wght parameters): ",
print.LKrig.R:        cat("Value(s) for weighting in GMRF (a.wght): ", unlist(LKinfo$alpha), 
print.LKrig.R:    cat(" ", fill = TRUE)
print.LKrig.R:        cat("Basis functions normalized so marginal process variance is stationary", 
print.LatticeKrig.R:	cat("Call:\n")
print.LatticeKrig.R:	  cat("NOTE: This is an 'inverse' model because U and  X matrices are supplied", fill=TRUE)}
print.LatticeKrig.R:	cat(" ", fill = TRUE)	
print.LatticeKrig.R:	cat(" ", fill = TRUE)
print.LatticeKrig.R:		cat("No fixed part of model", fill = TRUE)
print.LatticeKrig.R:			cat("Fixed part of model is a polynomial of degree", x$LKinfo$fixedFunctionArgs$m - 
print.LatticeKrig.R:			cat("Fixed part of model uses the function:", x$LKinfo$fixedFunction, 
print.LatticeKrig.R:			cat("with the argument list:", fill = TRUE)
print.LatticeKrig.R:	cat("Basis function : ", LKinfo$basisInfo$BasisType, 
print.LatticeKrig.R:	cat("Basis function used: ", LKinfo$basisInfo$BasisFunction, 
print.LatticeKrig.R:	cat("Distance metric: ", LKinfo$distance.type, fill = TRUE)
print.LatticeKrig.R:	cat(" ", fill = TRUE)
print.LatticeKrig.R:	cat("Lattice summary:", fill = TRUE)
print.LatticeKrig.R:	cat(LKinfo$nlevel, " Level(s)", LKinfo$latticeInfo$m, "basis functions", 
print.LatticeKrig.R:	cat(" ", fill = TRUE)
print.LatticeKrig.R:	cat(" ", fill = TRUE)
print.LatticeKrig.R:	cat("Nonzero entries in Ridge regression matrix", x$nonzero.entries, 
print.LatticeKrig.R:	cat(" ", fill = TRUE)
print.LatticeKrig.R:		cat("Value(s) for alpha: ", unlist(LKinfo$alpha), fill = TRUE)
print.LatticeKrig.R:		cat("alpha values passed as a vector for each level", fill = TRUE)
print.LatticeKrig.R:	cat(" ", fill = TRUE)
print.LatticeKrig.R:		cat("Value(s) for lattice dependence (a.wght): ", a.wght, fill = TRUE)
print.LatticeKrig.R:		cat("Value(s) for weighting in GMRF (a.wght): ", unlist(LKinfo$alpha), 
print.LatticeKrig.R:	cat(" ", fill = TRUE)
print.LatticeKrig.R:		cat("Basis functions normalized so marginal process variance is stationary", 
print.LatticeKrig.R:	  cat("\n", "NOTE: sigma and rho found by maximum likelihood for ", fill = TRUE)  
print.LatticeKrig.R:	  cat("fixed values of alpha and a.wght", fill = TRUE)
print.LatticeKrig.R:	  cat("\n"," Summary of MLE computation from optim:", fill=TRUE)
print.LatticeKrig.R:	  cat(" ", fill = TRUE)
print.LatticeKrig.R:	  cat("\n", "NOTE: parameters sigma, rho, and the a.wght found  ", fill = TRUE)  
print.LatticeKrig.R:	  cat("by maximum likelihood for fixed values of alpha", fill = TRUE)
print.LatticeKrig.R:	  cat(" Summary of MLE computation from optim:", fill=TRUE)
print.LatticeKrig.R:	  cat(" ", fill = TRUE)
