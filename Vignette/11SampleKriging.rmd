# Appendix C: Sample \ttt{LatticeKrig} calculation

The computations inside of \ttt{LatticeKrig} and \ttt{LKrig} can be hard to understand, so here we will work through several examples showing all of the linear algebra used. Some of the variable names will be changed from the code in the previous section so that they match the names in the linear algebra appendix and in the JCGS article.

## First Example: One level, no normalization

First, we create the data, create the basis/covariance function \ttt{basis}, and call \ttt{LKrig} to fit the data.

```{r Calculations1Setup}
lambda = 0.05
overlap = 2.5
basis <- function(d) {
  return(1/3 * (1-d)^6 * (35*d^2 + 18*d + 3) * (d < 1))
}

#clear x and y to make sure our data doesn't get overwritten
rm(x, y)
data(KrigingExampleData)
```

Next, we create an equally spaced lattice of 6 points in [0,1] and add 5 additional points on either side; since we only have 1 level in 1 dimension, this is relatively easy.

```{r Calculations1Lattice}
nc <- 6
ncBuffer <- 5

#finding the spacing for the lattice
delta <- 1/(nc-1)
latInside <- seq(from=0, to=1, by=delta)

#adding the buffer lattice points outside the interval
latBefore <- seq(to=0-delta, by=delta, length.out = ncBuffer)
latAfter <- seq(from=1+delta, by=delta, length.out = ncBuffer)
lattice <- c(latBefore, latInside, latAfter)
m <- length(lattice)
```

Now we create the covariance matrix for $\mathbf y$, which is $M_\lambda$, and the covariance matrix for the basis functions, which is $P$.

```{r Calculations1Covariance}
Phi <- basis(rdist(x, lattice) / (overlap*delta))
B <- LKDiag(c(-1, 2.01, -1), m)
Q <- t(B) %*% B
P <- solve(Q)
M <- Phi %*% P %*% t(Phi) + lambda*diag(1, length(x))
Minverse <- solve(M)
```

Finally, we can calculate our estimates for $\mathbf c$ and $\mathbf d$: \ttt{cHat} and \ttt{dHat}, respectively.

```{r Calculations1Fixed}
ones <- rep(1, length(x))
Z <- cbind(ones, x)
dHat <- solve(t(Z) %*% Minverse %*% Z, t(Z) %*% Minverse %*% y)
G <- t(Phi)  %*% Phi + lambda*Q
cHat <- solve(G) %*% t(Phi) %*% (y - Z %*% dHat)

info <- LKrigSetup(as.matrix(c(0,1)), NC = 6, NC.buffer = 5, nlevel = 1, a.wght = 2.01,
                   alpha = 1, lambda = 0.05, normalize = FALSE, LKGeometry = "LKInterval")
krigFit <- LKrig(x, y, LKinfo = info)

#compare kriging prediction with calculated prediction
xGrid <- seq(0,1,length = 200)
krigPredictions <- predict(krigFit, xGrid)
PhiPredict <- basis(rdist(xGrid, lattice) / (overlap*delta))
ZPredict <- cbind(rep(1, length(x)), xGrid)
predictions <- ZPredict %*% dHat + PhiPredict %*% cHat

#making covariance matrix and comparing it to the LKrig one
testCov <- Phi %*% P %*% t(Phi)
targetCov <- LKrig.cov(x, x, info)

test.for.zero(testCov, targetCov)
test.for.zero(dHat, krigFit$d.coef)
test.for.zero(cHat, krigFit$c.coef)
test.for.zero(krigPredictions, predictions)
```

## Second example: One level with normalization

In this example, we normalize \ttt{Phi} so that the basis functions have covariance 1 at each data point. This normalization will reduce artifacts in the kriging model that aren't present in the data near the edges of the window. We also print out the diagonal of the covariance matrix, $\Phi P \Phi^T$ - note that it is all ones.
```{r Calculations3New}
D <- Phi %*% P %*% t(Phi)
#discarding the off-diagonal elements of D
DS <- diag(diag(D)^(-1/2))
Phi <- DS %*% Phi
diag(Phi %*% P %*% t(Phi))

#calculating Phi matrix for prediction locations
xGrid <- seq(0,1,length = 200)
PhiPredict <- basis(rdist(xGrid, lattice) / (overlap*delta))
#normalizing PhiPredict too
DPredict <- PhiPredict %*% P %*% t(PhiPredict)
#discarding the off-diagonal elements of D
DPredictS <- diag(diag(DPredict)^(-1/2))
PhiPredict <- DPredictS %*% PhiPredict
```

The rest of the calculations proceed in the same way as the first section without normalization.

```{r Calculations3Finish}
M <- Phi %*% P %*% t(Phi) + lambda*diag(1, length(x))
Minverse <- solve(M)

Z <- cbind(1, x)
ZPredict <- cbind(1, xGrid)
dHat <- solve(t(Z) %*% Minverse %*% Z, t(Z) %*% Minverse %*% y)
G <- t(Phi)  %*% Phi + lambda*Q
cHat <- solve(G) %*% t(Phi) %*% (y - Z %*% dHat)
predictions <- ZPredict %*% dHat + PhiPredict %*% cHat

info <- LKrigSetup(as.matrix(c(0,1)), NC = 6, NC.buffer = 5, nlevel = 1,
                   a.wght = 2.01, alpha = 1, lambda = 0.05, LKGeometry = "LKInterval")
krigFit <- LKrig(x, y, LKinfo = info)
krigPredictions <- predict(krigFit, xGrid)

#making covariance matrix and comparing it to the LKrig one
testCov <- Phi %*% P %*% t(Phi)
targetCov <- LKrig.cov(x, x, info)

test.for.zero(testCov, targetCov)
test.for.zero(dHat, krigFit$d.coef)
test.for.zero(cHat, krigFit$c.coef)
test.for.zero(krigPredictions, predictions)

```

## Third Example: Three levels, no normalization

The setup in this example is almost the same as in the first one; the only differences are the different random seed and the different values of \ttt{nlevel} and \ttt{alpha} in the \ttt{LKinfo} object. The value of \ttt{alpha} is chosen so that each level has half as much weight as the previous and the sum of all the weights is 1.

```{r Calculations2Setup}
lambda <- 0.05
overlap <- 2.5
basis <- function(d) {
  return(1/3 * (1-d)^6 * (35*d^2 + 18*d + 3) * (d < 1))
}
```

Making the lattice is now more complicated, since we need to create three different levels. However, note that the first level is the same as before, and the new levels just have lattice points 2x and 4x closer together.

```{r Calculations2Lattice}
nc <- 6
ncBuffer <- 5
delta <- 1 / (nc-1)
L1Inside <- seq(from=0, to=1, by=delta)
L1Before <- seq(to=0-delta, by=delta, length.out = ncBuffer)
L1After <- seq(from=1+delta, by=delta, length.out = ncBuffer)
L1 <- c(L1Before, L1Inside, L1After)

L2Inside <- seq(from=0, to=1, by=delta/2)
L2Before <- seq(to=0-delta/2, by=delta/2, length.out = ncBuffer)
L2After <- seq(from=1+delta/2, by=delta/2, length.out = ncBuffer)
L2 <- c(L2Before, L2Inside, L2After)

L3Inside <- seq(from=0, to=1, by=delta/4)
L3Before <- seq(to=0-delta/4, by=delta/4, length.out = ncBuffer)
L3After <- seq(from=1+delta/4, by=delta/4, length.out = ncBuffer)
L3 <- c(L3Before, L3Inside, L3After)

s1 <- length(L1)
s2 <- length(L2)
s3 <- length(L3)
c(s1, s2, s3)
```

Note that the values of \ttt{s1, s2, s3} don't follow a strict 1:2 ratio as we might expect; this is because of the lattice points outside the region, and because of the boundaries. Specifically, \ttt{s1 = 16} because there are \ttt{nc = 6} lattice points covering the interval, with 5 gaps between them, and an additional 5 lattice points on each side of the interval. At the second level, the gaps are half as wide, so the 5 gaps become 10; there are now 11 lattice points in the interval and 5 on each side, giving the total \ttt{s2 = 21}. Similarly, at the third level the 10 gaps become 20, making 21 lattice points in the interval and 5 on either side, so we have \ttt{s3 = 31}.

Now we create the covariance matrix for $\mathbf y$, which is $M_\lambda$, and the covariance matrix for the basis functions, which is $P$. Now that we have 3 different lattice sizes, making $Q = P^{-1}$ becomes more difficult, since it's a block-diagonal matrix with a block entry for each different lattice size.

```{r Calculations2Covariance}
alpha <- c(4, 2, 1)/7
Phi1 <- basis(rdist(x, L1) / (overlap*delta)) * sqrt(alpha[1])
Phi2 <- basis(rdist(x, L2) / (overlap*delta/2)) * sqrt(alpha[2])
Phi3 <- basis(rdist(x, L3) / (overlap*delta/4)) * sqrt(alpha[3])
Phi <- cbind(Phi1, Phi2, Phi3)

B1 <- LKDiag(c(-1, 2.01, -1), s1)
B2 <- LKDiag(c(-1, 2.01, -1), s2)
B3 <- LKDiag(c(-1, 2.01, -1), s3)
Q1 <- t(B1) %*% B1
Q2 <- t(B2) %*% B2
Q3 <- t(B3) %*% B3
Q <- matrix(0, nrow = s1+s2+s3, ncol = s1+s2+s3)

#putting Q1, Q2, Q3 into block-diagonal matrix Q
Q[1:s1, 1:s1] <- Q1
Q[(s1+1):(s1+s2), (s1+1):(s1+s2)] <- Q2
Q[(s1+s2+1):(s1+s2+s3), (s1+s2+1):(s1+s2+s3)] <- Q3
P <- solve(Q)
M <- Phi %*% P %*% t(Phi) + lambda*diag(1, length(x))
Minverse <- solve(M)
```

Finding coefficients

```{r Calculations2Fixed}
ones <- rep(1, length(x))
Z <- cbind(ones, x)
dHat <- solve(t(Z) %*% Minverse %*% Z, t(Z) %*% Minverse %*% y)
G <- t(Phi)  %*% Phi + lambda*Q
cHat <- solve(G) %*% t(Phi) %*% (y - Z %*% dHat)

info <- LKrigSetup(as.matrix(c(0,1)), NC = 6, nlevel = 3, a.wght = 2.01, alpha = c(4,2,1)/7,
                   lambda = 0.05, normalize = FALSE, LKGeometry = "LKInterval")
krigFit <- LKrig(x, y, LKinfo = info)

#making covariance matrix and comparing it to the LKrig one
targetBasis <- spam2full(LKrig.basis(x, info))
test.for.zero(targetBasis, Phi)
testCov <- Phi %*% P %*% t(Phi)
targetCov <- LKrig.cov(x, x, info)
test.for.zero(testCov, targetCov)
test.for.zero(dHat, krigFit$d.coef)
test.for.zero(cHat, krigFit$c.coef)
```

## Using the kriging equations directly

Recall the standard kriging equations for $\hat{\bld c}$ and $\hat{\bld d}$ in Appendix A:
\begin{align*}
\hat{\bld d} &= (Z^T \Sigma^{-1} Z)^{-1} Z^T \Sigma^{-1} \\
\hat{\bld c} &= P \Phi^T \Sigma_{11}^{-1}(\bld y - Z \bld d)
\end{align*}
In this section, we will compute the estimates directly using these equations to show that the computations in LatticeKrig match them. For brevity, we will only consider the case with one level and no normalization; adjustments for more levels and normalization can be made in the same way as in the previous section. 

```{r KrigingEquations}
data(KrigingExampleData)
info <- LKrigSetup(as.matrix(c(0,1)), NC = 6, NC.buffer = 5, nlevel = 1,
                   a.wght = 3, alpha = 1, lambda = 0.05, LKGeometry = "LKInterval")
krigFit <- LKrig(x, y, LKinfo = info)
nc <- 6
ncBuffer <- 5
lambda = 0.05
delta <- 1/(nc-1)
latInside <- seq(from=0, to=1, by=delta)
latBefore <- seq(to=0-delta, by=delta, length.out = ncBuffer)
latAfter <- seq(from=1+delta, by=delta, length.out = ncBuffer)
lattice <- c(latBefore, latInside, latAfter)
overlap <- 2.5

cov <- function(d) {
  s <- d/(overlap*delta)
  return(1/3 * (1-d)^6 * (35*d^2 + 18*d + 3) * (d < 1))
}
Sigma <- cov(rdist(x, x)) + lambda*diag(1, length(x))
SigmaInv <- solve(Sigma)
Phi <- cov(rdist(x, lattice))
P <- cov(rdist(lattice, lattice))
ones <- rep(1, length(x))
Z <- cbind(ones, x)
dHat <- solve(t(Z) %*% SigmaInv %*% Z) %*% t(Z) %*% SigmaInv
cHat <- P %*% t(Phi) %*% SigmaInv %*% (y - Z %*% dHat)
test.for.zero(dHat, krigFit$d.coef)
test.for.zero(cHat, krigFit$c.coef)
```