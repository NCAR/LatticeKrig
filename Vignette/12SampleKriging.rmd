# Appendix C: Sample \ttt{LatticeKrig} calculation

The computations inside of \ttt{LatticeKrig} and \ttt{LKrig} can be hard to understand, so here we will work through several examples, showing all of the linear algebra used. Some of the variable names will be changed from the code in the previous section so that they match the names in the linear algebra appendix and in the paper.

## First Example: One level, no normalization

First, we create the data, create the basis/covariance function \ttt{basis}, and call \ttt{LKrig} to fit the data.

```{r Calculations1Setup}
#clear x and y to make sure our data doesn't get overwritten
rm(x, y)
lambda = 0.05
overlap = 2.5
basis <- function(d) {
  return(1/3 * (1-d)^6 * (35*d^2 + 18*d + 3) * (d < 1))
}
data(KrigingExampleData)
info <- LKrigSetup(as.matrix(c(0,1)), NC = 6, NC.buffer = 5, nlevel = 1, a.wght = 2.01, alpha = 1, lambda = 0.05, normalize = FALSE, LKGeometry = "LKInterval")
krigFit <- LKrig(x, y, LKinfo = info)
```

Next, we create the lattice; since we only have 1 level in 1 dimension, this is relatively easy.

```{r Calculations1Lattice}
nc <- 6
ncBuffer <- 5

#finding the spacing for the lattice
LGap <- 1/(nc-1)
latInside <- seq(from=0, to=1, by=LGap)

#adding the buffer lattice points outside the interval
latBefore <- seq(to=0-LGap, by=LGap, length.out = ncBuffer)
latAfter <- seq(from=1+LGap, by=LGap, length.out = ncBuffer)
lattice <- c(latBefore, latInside, latAfter)
s <- length(lattice)
```

Now we create the covariance matrix for $\mathbf y$, which is $M_\lambda$, and the covariance matrix for the basis functions, which is $P$.

```{r Calculations1Covariance}
Phi <- basis(rdist(x, lattice) / (overlap*LGap))
B <- LKDiag(c(-1, 2.01, -1), s)
Q <- t(B) %*% B
P <- solve(Q)
M <- Phi %*% P %*% t(Phi) + lambda*diag(1, length(x))
Minverse <- solve(M)
```

Finally, we can calculate our estimates for $\mathbf c$ and $\mathbf d$: \ttt{cHat} and \ttt{dHat}, respectively.

```{r Calculations1Fixed}
ones <- rep(1, length(x))
Z <- cbind(ones, x)
dHat <- solve(t(Z) %*% Minverse %*% Z, t(Z) %*% Minverse %*% y)
G <- t(Phi)  %*% Phi + lambda*Q
cHat <- solve(G) %*% t(Phi) %*% (y - Z %*% dHat)

#making covariance matrix and comparing it to the LKrig one
testCov <- Phi %*% P %*% t(Phi)
targetCov <- LKrig.cov(x, x, info)
test.for.zero(testCov, targetCov)
test.for.zero(dHat, krigFit$d.coef)
test.for.zero(cHat, krigFit$c.coef)

#compare kriging prediction with calculated prediction
xGrid <- seq(0,1,length = 200)
krigPredictions <- predict(krigFit, xGrid)
PhiPredict <- basis(rdist(xGrid, lattice) / (overlap*LGap))
ZPredict <- cbind(rep(1, length(x)), xGrid)
predictions <- ZPredict %*% dHat + PhiPredict %*% cHat
test.for.zero(krigPredictions, predictions)
```

## Second Example: Three levels, no normalization

The setup in this example is almost the same as in the first one; the only differences are the different random seed and the different values of \ttt{nlevel} and \ttt{alpha} in the \ttt{LKinfo} object. The value of \ttt{alpha} is chosen so that each level has half as much weight as the previous and the sum of all the weights is 1.

```{r Calculations2Setup}
lambda <- 0.05
overlap <- 2.5
basis <- function(d) {
  return(1/3 * (1-d)^6 * (35*d^2 + 18*d + 3) * (d < 1))
}
data(KrigingExampleData)
info <- LKrigSetup(as.matrix(c(0,1)), NC = 6, nlevel = 3, a.wght = 2.01, alpha = c(4,2,1)/7, lambda = 0.05, normalize = FALSE, LKGeometry = "LKInterval")
krigFit <- LKrig(x, y, LKinfo = info)
```

Making the lattice is now more complicated, since we need to create three different levels. However, note that the first level is the same as before, and the new levels just have lattice points 2x and 4x closer together.

```{r Calculations2Lattice}
nc <- 6
ncBuffer <- 5
LGap <- 1 / (nc-1)
L1Inside <- seq(from=0, to=1, by=LGap)
L1Before <- seq(to=0-LGap, by=LGap, length.out = ncBuffer)
L1After <- seq(from=1+LGap, by=LGap, length.out = ncBuffer)
L1 <- c(L1Before, L1Inside, L1After)

L2Inside <- seq(from=0, to=1, by=LGap/2)
L2Before <- seq(to=0-LGap/2, by=LGap/2, length.out = ncBuffer)
L2After <- seq(from=1+LGap/2, by=LGap/2, length.out = ncBuffer)
L2 <- c(L2Before, L2Inside, L2After)

L3Inside <- seq(from=0, to=1, by=LGap/4)
L3Before <- seq(to=0-LGap/4, by=LGap/4, length.out = ncBuffer)
L3After <- seq(from=1+LGap/4, by=LGap/4, length.out = ncBuffer)
L3 <- c(L3Before, L3Inside, L3After)

s1 <- length(L1)
s2 <- length(L2)
s3 <- length(L3)
c(s1, s2, s3)
```

Note that the values of \ttt{s1, s2, s3} don't follow a strict 1:2 ratio as we might expect; this is because of the lattice points outside the region, and because of the boundaries. Specifically, \ttt{s1 = 16} because there are \ttt{nc = 6} lattice points covering the interval, with 5 gaps between them, and an additional 5 lattice points on each side of the interval. At the second level, the gaps are half as wide, so the 5 gaps become 10; there are now 11 lattice points in the interval and 5 on each side, giving the total \ttt{s2 = 21}. Similarly, at the third level the 10 gaps become 20, making 21 lattice points in the interval and 5 on either side, so we have \ttt{s3 = 31}.

Now we create the covariance matrix for $\mathbf y$, which is $M_\lambda$, and the covariance matrix for the basis functions, which is $P$. Now that we have 3 different lattice sizes, making $Q = P^{-1}$ becomes more difficult, since it's a block-diagonal matrix with a block entry for each different lattice size.

```{r Calculations2Covariance}
alpha <- c(4, 2, 1)/7
Phi1 <- basis(rdist(x, L1) / (overlap*LGap)) * sqrt(alpha[1])
Phi2 <- basis(rdist(x, L2) / (overlap*LGap/2)) * sqrt(alpha[2])
Phi3 <- basis(rdist(x, L3) / (overlap*LGap/4)) * sqrt(alpha[3])
Phi <- cbind(Phi1, Phi2, Phi3)
targetBasis <- spam2full(LKrig.basis(x, info))
test.for.zero(targetBasis, Phi)

B1 <- LKDiag(c(-1, 2.01, -1), s1)
B2 <- LKDiag(c(-1, 2.01, -1), s2)
B3 <- LKDiag(c(-1, 2.01, -1), s3)
Q1 <- t(B1) %*% B1
Q2 <- t(B2) %*% B2
Q3 <- t(B3) %*% B3
Q <- matrix(0, nrow = s1+s2+s3, ncol = s1+s2+s3)

#putting Q1, Q2, Q3 into block-diagonal matrix Q
Q[1:s1, 1:s1] <- Q1
Q[(s1+1):(s1+s2), (s1+1):(s1+s2)] <- Q2
Q[(s1+s2+1):(s1+s2+s3), (s1+s2+1):(s1+s2+s3)] <- Q3
P <- solve(Q)
M <- Phi %*% P %*% t(Phi) + lambda*diag(1, length(x))
Minverse <- solve(M)
```

Finding coefficients

```{r Calculations2Fixed}
ones <- rep(1, length(x))
Z <- cbind(ones, x)
dHat <- solve(t(Z) %*% Minverse %*% Z, t(Z) %*% Minverse %*% y)
G <- t(Phi)  %*% Phi + lambda*Q
cHat <- solve(G) %*% t(Phi) %*% (y - Z %*% dHat)

#making covariance matrix and comparing it to the LKrig one
testCov <- Phi %*% P %*% t(Phi)
targetCov <- LKrig.cov(x, x, info)
test.for.zero(testCov, targetCov)
test.for.zero(dHat, krigFit$d.coef)
test.for.zero(cHat, krigFit$c.coef)
```

## Using the kriging equations directly

Recall the equations for $\hat{\bld c}$ and $\hat{bld d}$ in Appendix A:
\begin{align*}
\hat{\bld d} &= (Z^T \Sigma^{-1} Z)^{-1} Z^T \Sigma^{-1} \\
\hat{\bld c} &= P \Phi^T \Sigma_{11}^{-1}(\bld y - Z \bld d)
\end{align*}
In this appendix, we will compute the estimates directly using these equations to show that the computations in LatticeKrig match them.