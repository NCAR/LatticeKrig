obj<- sreg( x,y)
xg<- seq( -2,3,,500)
yg<- predict( obj, xg)
lines( xg, yg, col="red")
plot( x,y, xlim=c(-2,3), ylim=range(c( y, yg)))
lines( xg, yg, col="red")
obj2<- Krig( x,y, theta=1.0)
dim( x)
obj2<- Krig( cbind(x),y, theta=1.0)
yg2<- predict( obj2, xg)
lines( xg, yg2, col="green4")
help( Krig)
obj2<- Krig( cbind(x),y, Covariance=Matern, smoothness=1.0, theta=1.0)
yg2<- predict( obj2, xg)
lines( xg, yg2, col="green4")
obj2<- Krig( cbind(x),y, Covariance=Matern, smoothness=1.0, theta=1.0, m=1)
yg2<- predict( obj2, xg)
lines( xg, yg2, col="green4")
14.5* 15.5
13.5* 15.5
13.5* 15.5/22
source('~/Home/Repositories/LatticeKrig/R/ModelLKSphere.R', echo=TRUE)
library( LatticeKrig)
remove( list=ls())
help( LKSphere)
set.seed(124)
N<- 1e3
NC<- 3
x0<- matrix( rnorm(3*N), ncol=3)
x0<- x0/ sqrt( rowSums( x0^2))
x<-  toSphere( x0 )
# the true function for testing -- a bump at the direction alpha
fun<- function(X){
alpha<-  c( .4,.2,1)
alpha<- alpha/ sqrt( sum( alpha^2))
( 1 + c(( X)%*%alpha) )^2
}
ytrue <- fun(x0)
y<- ytrue + .2*rnorm( length(ytrue))
xr=cbind( c(-180, 180), c(-90,90))
# this defines about 3300 basis functions
LKinfo1<- LKrigSetup( xr,
NC=NC, LKGeometry="LKSphere", a.wght=1.5,
nlevel=1, alpha = 1.0,
choleskyMemory=list(nnzR= 20E6),
normalize=FALSE)
out<- LatticeKrig( x,y, LKinfo=LKinfo1)
source('~/Home/Repositories/LatticeKrig/R/ModelLKSphere.R', echo=TRUE)
look<- LKrigSAR.LKSphere( LKinfo1)
look<- LKrigSAR.LKSphere( LKinfo1,1)
names( look)
library( LatticeKrig)
set.seed(124)
N<- 1e3
NC<- 3
x0<- matrix( rnorm(3*N), ncol=3)
x0<- x0/ sqrt( rowSums( x0^2))
x<-  toSphere( x0 )
# the true function for testing -- a bump at the direction alpha
fun<- function(X){
alpha<-  c( .4,.2,1)
alpha<- alpha/ sqrt( sum( alpha^2))
( 1 + c(( X)%*%alpha) )^2
}
ytrue <- fun(x0)
y<- ytrue + .2*rnorm( length(ytrue))
xr=cbind( c(-180, 180), c(-90,90))
# this defines about 3300 basis functions
LKinfo1<- LKrigSetup( xr,
NC=NC, LKGeometry="LKSphere", a.wght=1.5,
nlevel=1, alpha = 1.0,
choleskyMemory=list(nnzR= 20E6),
normalize=FALSE)
out<- LatticeKrig( x,y, LKinfo=LKinfo1)
out
surface( out)
quartz()
surface( out)
LKinfo1<- LKrigSetup( xr,
NC=NC, LKGeometry="LKSphere", a.wght=1.01,
nlevel=1, alpha = 1.0,
choleskyMemory=list(nnzR= 20E6),
normalize=FALSE)
out<- LatticeKrig( x,y, LKinfo=LKinfo1)
surface( out)
set.seed(124)
N<- 1e4
NC<- 4
x0<- matrix( rnorm(3*N), ncol=3)
x0<- x0/ sqrt( rowSums( x0^2))
x<-  toSphere( x0 )
# the true function for testing -- a bump at the direction alpha
fun<- function(X){
alpha<-  c( .4,.2,1)
alpha<- alpha/ sqrt( sum( alpha^2))
( 1 + c(( X)%*%alpha) )^2
}
ytrue <- fun(x0)
y<- ytrue + .2*rnorm( length(ytrue))
xr=cbind( c(-180, 180), c(-90,90))
# this defines about 3300 basis functions
LKinfo1<- LKrigSetup( xr,
NC=NC, LKGeometry="LKSphere", a.wght=1.01,
nlevel=1, alpha = 1.0,
choleskyMemory=list(nnzR= 20E6),
normalize=FALSE)
out<- LatticeKrig( x,y, LKinfo=LKinfo1)
surface( out)
out
ytrue <- fun(x0)
y<- ytrue + .05*rnorm( length(ytrue))
xr=cbind( c(-180, 180), c(-90,90))
# this defines about 3300 basis functions
LKinfo1<- LKrigSetup( xr,
NC=NC, LKGeometry="LKSphere", a.wght=1.01,
nlevel=1, alpha = 1.0,
choleskyMemory=list(nnzR= 20E6),
normalize=FALSE)
out<- LatticeKrig( x,y, LKinfo=LKinfo1)
out
surface(out)
set.seed(124)
N<- 1e4
NC<- 3
x0<- matrix( rnorm(3*N), ncol=3)
x0<- x0/ sqrt( rowSums( x0^2))
x<-  toSphere( x0 )
# the true function for testing -- a bump at the direction alpha
fun<- function(X){
alpha<-  c( .4,.2,1)
alpha<- alpha/ sqrt( sum( alpha^2))
( 1 + c(( X)%*%alpha) )^2
}
ytrue <- fun(x0)
y<- ytrue + .05*rnorm( length(ytrue))
xr=cbind( c(-180, 180), c(-90,90))
# this defines about 3300 basis functions
LKinfo1<- LKrigSetup( xr,
NC=NC, LKGeometry="LKSphere", a.wght=1.01,
nlevel=3, alpha = c(1.0,.5,.25),
choleskyMemory=list(nnzR= 20E6),
normalize=FALSE)
out<- LatticeKrig( x,y, LKinfo=LKinfo1)
surface( out)
out
fun<- function(X){
alpha<-  c( .4,.2,1)
alpha<- alpha/ sqrt( sum( alpha^2))
4*( 1 + c(( X)%*%alpha) )^2
}
ytrue <- fun(x0)
y<- ytrue + .05*rnorm( length(ytrue))
xr=cbind( c(-180, 180), c(-90,90))
# this defines about 3300 basis functions
LKinfo1<- LKrigSetup( xr,
NC=NC, LKGeometry="LKSphere", a.wght=1.01,
nlevel=3, alpha = c(1.0,.5,.25),
choleskyMemory=list(nnzR= 20E6),
normalize=FALSE)
out<- LatticeKrig( x,y, LKinfo=LKinfo1)
surface( out)
out
LKinfo1<- LKrigSetup( xr,
NC=NC, LKGeometry="LKSphere", a.wght=1.01,
nlevel=3, alpha = c(1.0,.5,.25)^2,
choleskyMemory=list(nnzR= 20E6),
normalize=FALSE)
out<- LatticeKrig( x,y, LKinfo=LKinfo1)
surface( out)
out
quartz()
LKinfo1<- LKrigSetup( xr,
NC=NC, LKGeometry="LKSphere", a.wght=3.01,
nlevel=3, alpha = c(1.0,.5,.25)^2,
choleskyMemory=list(nnzR= 20E6),
normalize=FALSE)
out<- LatticeKrig( x,y, LKinfo=LKinfo1)
surface( out)
x0<- c( 2,2,3)
x0<- c( 40,50)
x0<- toSphere( rbind( x0))
toSphere
x0<- diectionCosines( rbind( x0))
x0<- directionCosines( rbind( x0))
x0
x1<- c( 0,1,0)
xx1<- rbind( x1, c(1,0,0))
x1<- rbind( x1, c(1,0,0))
x1<- rbind( x1, c(0,0,1))
projectionSphere(x0,x1)
library( LatticeKrig)
ls (pos=2)
help( LKrigFindLambdaAwght)
data(NorthAmericanRainfall)
# rename for less typing
x<- cbind( NorthAmericanRainfall$longitude, NorthAmericanRainfall$latitude)
# total precip in 1/10 mm for JJA
y<- log10(NorthAmericanRainfall$precip)
# cut down the size of this data set so examples run quickly
# examples also work with  the full data set. Also try NC= 100 for a
# nontrivial model.
ind<- x[,1] > -90 & x[,2] < 35 #
x<- x[ind,]
y<- y[ind]
LKinfo<- LKrigSetup(x,NC=8,nlevel=1, a.wght=4.2, alpha=1.0)
lambdaFit<- LKrigFindLambda( x,y,LKinfo=LKinfo)
lambdaFit$summary
LKinfo<- LKrigSetup(x,NC=8,nlevel=1, a.wght=4.2, alpha=1.0)
lambdaFit<- LKrigFindLambda( x,y,LKinfo=LKinfo)
lambdaFit$summary
LKrigFindLambdaAwght( x,y,LKinfo=LKinfo)
LKinfo$a.wght
LKrigFindLambdaAwght( x,y,LKinfo=LKinfo, verbose=TRUE)
omega2Awght( -1, LKinfo)
omega2Awght
LKinfo$floorAwght
source('~/Home/Repositories/LatticeKrig/R/Awght2Omega.R', echo=TRUE)
source('~/Home/Repositories/LatticeKrig/R/LKrigFindLambdaAwght.R', echo=TRUE)
LKrigFindLambdaAwght( x,y,LKinfo=LKinfo)
library( LatticeKrig)
ls( pos=2)
help( toSphere)
help( "directionCosines")
prompt(diretionCosines)
prompt(directionCosines)
toSphere
directionCosines
projectionSphere
IcosohedronGrid
lGrid<- make.surface.grid(  x= seq( -10,10,, 40), y= seq( -20,20,,40))
lGrid<- make.surface.grid(  list(x= seq( -10,10,, 40), y= seq( -20,20,,40)) )
plot( lGrid)
quartz()
plot( lGrid)
lGrid<- make.surface.grid(  list(x= seq( -10,10,, 10), y= seq( -20,20,,10)) )
dGrid<- directionCosines( lGrid)
pairs( dGrid)
quartz()
pairs( dGrid)
library( rgl); plot3d( dGrid)
library( rgl); plot3d( V )
V = matrix(c(0, 1, phi, 0, 1, -phi, 0, -1, phi, 0, -1, -phi,
1, phi, 0, -1, phi, 0, 1, -phi, 0, -1, -phi, 0, phi,
0, 1, -phi, 0, 1, phi, 0, -1, -phi, 0, -1), 12, 3, byrow = TRUE)
phi = (1 + sqrt(5))/2
V = matrix(c(0, 1, phi, 0, 1, -phi, 0, -1, phi, 0, -1, -phi,
1, phi, 0, -1, phi, 0, 1, -phi, 0, -1, -phi, 0, phi,
0, 1, -phi, 0, 1, phi, 0, -1, -phi, 0, -1), 12, 3, byrow = TRUE)
plot3d( V)
args( plot3d)
plot3d( V, radius=.3 )
plot3d( V, radius=10 )
help( plot3d)
plot3d( V, size=10 )
plot3d( V, size=10, col="red4" )
library(LatticeKrig)
oemga2Awght
omega2Awght
args( LKrigFindLambdaAwght)
library( LatticeKrig)
test.for.zero.flag <- 1
set.seed( 122)
M<- 1e2 # nummber of independent spatial replications
N<- 5e3 # number of obs
x<- matrix( runif(2*N ), N,2)
lambdaTrue<- .1^2
#NOTE: true rho is 1.0
LKinfoTrue<- LKrigSetup(x,NC=8, nlevel=3, a.wght= 4.2,
alpha=c(1.0,.5,.25), lambda=lambdaTrue,
normalize=FALSE, NC.buffer=2)
f<- LKrig.sim( x, LKinfoTrue, M=M)
E<- matrix( rnorm( prod( dim( f))), nrow= nrow( f), ncol=ncol(f) )
Y<- f + sqrt(lambdaTrue)* E
LKinfoTest<- LKinfoUpdate( LKinfoTrue, a.wght=4.3,
lambda=lambdaTrue*(1.05))
Fit1<- LKrigFindLambdaAwght( x,Y,LKinfo=LKinfoTest,
verbose=FALSE)
print(Fit1$summary)
q()
library(LatticeKrig)
test.for.zero.flag <- 1
set.seed( 122)
M<- 1e2 # nummber of independent spatial replications
N<- 5e3 # number of obs
x<- matrix( runif(2*N ), N,2)
lambdaTrue<- .1^2
#NOTE: true rho is 1.0
LKinfoTrue<- LKrigSetup(x,NC=8, nlevel=3, a.wght= 4.2,
alpha=c(1.0,.5,.25), lambda=lambdaTrue,
normalize=FALSE, NC.buffer=2)
f<- LKrig.sim( x, LKinfoTrue, M=M)
E<- matrix( rnorm( prod( dim( f))), nrow= nrow( f), ncol=ncol(f) )
Y<- f + sqrt(lambdaTrue)* E
LKinfoTest<- LKinfoUpdate( LKinfoTrue, a.wght=4.3,
lambda=lambdaTrue*(1.05))
Fit1<- LKrigFindLambdaAwght( x,Y,LKinfo=LKinfoTest,
verbose=FALSE)
print(Fit1$summary)
Fit1$a.wght.MLE
LKinfoTest2<- LKinfoUpdate(LKinfoTest, a.wght= Fit1$a.wght.MLE)
Fit2<- LKrigFindLambda( x,Y,LKinfo=LKinfoTest2)
Fit2$summary
Fit2$lambda.MLE
Fit2$summary["lnProfLike"]
Fit1$summary["lnProfLike"]
names( Fit2)
Fit2$lnLike.eval
LKinfoTest2<- LKinfoUpdate(LKinfoTest, a.wght= Fit1$a.wght.MLE, lambda=Fit1$lambda.MLE )
Fit2<- LKrigFindLambda( x,Y,LKinfo=LKinfoTest2)
Fit2$lnLike.eval
Fit1$summary["lnProfLike"]
Fit1$lnLike.eval
Fit1$summary
Fit1
plot( Fit1$lnLike.eval[,c(1,5)],log="x")
plot( log10(Fit1$lnLike.eval[,1]), Fit1$lnLike.eval[,5] xlim=c(-3,-1.5))
plot( log10(Fit1$lnLike.eval[,1]), Fit1$lnLike.eval[,5], xlim=c(-3,-1.5))
sort( Fit1$lnLike.eval[,5] )
plot( log10(Fit1$lnLike.eval[,1]), Fit1$lnLike.eval[,5], xlim=c(-3,-1.5), ylim=c(328000,33900))
plot( log10(Fit1$lnLike.eval[,1]), Fit1$lnLike.eval[,5], xlim=c(-3,-1.5), ylim=c(328000,339000))
plot( log10(Fit1$lnLike.eval[,1]), Fit1$lnLike.eval[,5], xlim=c(-3,-1.5), ylim=c(328000,339000))
points( log10(Fit1$lambda.MLE),Fit1$summary["lnProfLike"], col="red")
plot( log10(Fit2$lnLike.eval[,1]), Fit1$lnLike.eval[,5], xlim=c(-3,-1.5), ylim=c(328000,339000))
points( log10(Fit2$lambda.MLE),Fit2$summary["lnProfLike"], col="red")
plot( log10(Fit2$lnLike.eval[,1]), Fit2$lnLike.eval[,5], xlim=c(-3,-1.5), ylim=c(328000,339000))
points( log10(Fit2$lambda.MLE),Fit2$summary["lnProfLike"], col="red")
Fit2$lnLike.eval
plot( log10(Fit2$lnLike.eval[,1]), Fit2$lnLike.eval[,4], xlim=c(-3,-1.5), ylim=c(328000,339000))
points( log10(Fit2$lambda.MLE),Fit2$summary["lnProfLike"], col="red")
Fit2$summary["lnProfLike"]
Fit1$summary["lnProfLike"]
max(Fit1$lnLike.eval[,5] )
Fit1<- LKrigFindLambdaAwght( x,Y,LKinfo=LKinfoTest,
verbose=TRUE)
Fit2$summary
Fit2$lambda.MLE
Fit1$omega.MLE
omega2Awght( Fit1$omega.MLE, LKinfoTest )
set.seed( 122)
M<- 1e2 # nummber of independent spatial replications
N<- 5e3 # number of obs
x<- matrix( runif(2*N ), N,2)
lambdaTrue<- .1^2
#NOTE: true rho is 1.0
LKinfoTrue<- LKrigSetup(x,NC=8, nlevel=3, a.wght= 4.2,
alpha=c(1.0,.5,.25), lambda=lambdaTrue,
normalize=FALSE, NC.buffer=2)
f<- LKrig.sim( x, LKinfoTrue, M=M)
E<- matrix( rnorm( prod( dim( f))), nrow= nrow( f), ncol=ncol(f) )
Y<- f + sqrt(lambdaTrue)* E
LKinfoTest<- LKinfoUpdate( LKinfoTrue, a.wght=4.3,
lambda=lambdaTrue*(1.05))
Fit1<- LKrigFindLambdaAwght( x,Y,LKinfo=LKinfoTest,
verbose=FALSE)
source('~/Home/Repositories/LatticeKrig/R/LKrigFindLambdaAwght.R', echo=TRUE)
Fit1<- LKrigFindLambdaAwght( x,Y,LKinfo=LKinfoTest,
verbose=FALSE)
print(Fit1$summary)
plot( log10(Fit1$lnLike.eval[,1]), Fit1$lnLike.eval[,5], xlim=c(-3,-1.5), ylim=c(328000,339000))
points( log10(Fit1$lambda.MLE),Fit1$summary["lnProfLike"], col="red")
plot( log10(Fit2$lnLike.eval[,1]), Fit2$lnLike.eval[,4], xlim=c(-3,-1.5), ylim=c(328000,339000))
points( log10(Fit2$lambda.MLE),Fit2$summary["lnProfLike"], col="red")
LKinfoTest2<- LKinfoUpdate(LKinfoTest, a.wght= Fit1$a.wght.MLE, lambda=Fit1$lambda.MLE )
Fit2<- LKrigFindLambda( x,Y,LKinfo=LKinfoTest2)
Fit2$summary
Fit2$lambda.MLE
test.for.zero( Fit2$summary["lnProfLike"],
Fit1$summary["lnProfLike"], tol=2e-7, tag=" lambda MLE")
test.for.zero( Fit2$summary["lnProfLike"],
Fit1$summary["lnProfLike"], tol=1e-6, tag=" lambda MLE")
library( LatticeKrig)
M<- 1e3 # nummber of independent spatial replications
N<- 1e2 # number of obs
x<- matrix( runif(2*N ), N,2)
lambdaTrue<- .05^2
#NOTE: true rho is 1.0
LKinfoTrue<- LKrigSetup(x,NC=3, nlevel=3, a.wght= 4.2,
alpha=c(1.0,.5,.25), lambda=lambdaTrue,
normalize=FALSE, NC.buffer=2)
f<- LKrig.sim( x, LKinfoTrue, M=M)
E<- matrix( rnorm( prod( dim( f))), nrow= nrow( f), ncol=ncol(f) )
Y<- f + sqrt(lambdaTrue)* E
LKinfoTest<- LKinfoUpdate( LKinfoTrue, a.wght=4.3,
lambda=lambdaTrue*(1.05))
Fit1<- LKrigFindLambdaAwght( x,Y,LKinfo=LKinfoTest,
verbose=FALSE)
print(Fit1$summary)
LKinfoTrue<- LKrigSetup(x,NC=3, nlevel=3, a.wght= 4.2,
alpha=c(1.0,.5,.25), lambda=lambdaTrue,
normalize=FALSE, NC.buffer=2, m=0)
f<- LKrig.sim( x, LKinfoTrue, M=M)
E<- matrix( rnorm( prod( dim( f))), nrow= nrow( f), ncol=ncol(f) )
Y<- f + sqrt(lambdaTrue)* E
LKinfoTest<- LKinfoUpdate( LKinfoTrue, a.wght=4.3,
lambda=lambdaTrue*(1.05))
Fit1<- LKrigFindLambdaAwght( x,Y,LKinfo=LKinfoTest,
verbose=FALSE)
LKrigSetu
LKrigSetup
args( LKrigSetup)
M<- 1e3 # nummber of independent spatial replications
N<- 1e2 # number of obs
x<- matrix( runif(2*N ), N,2)
lambdaTrue<- .05^2
#NOTE: true rho is 1.0
LKinfoTrue<- LKrigSetup(x,NC=3, nlevel=3, a.wght= 4.2,
alpha=c(1.0,.5,.25), lambda=lambdaTrue,
normalize=FALSE, NC.buffer=2,fixedFunction = NULL )
f<- LKrig.sim( x, LKinfoTrue, M=M)
E<- matrix( rnorm( prod( dim( f))), nrow= nrow( f), ncol=ncol(f) )
Y<- f + sqrt(lambdaTrue)* E
LKinfoTest<- LKinfoUpdate( LKinfoTrue, a.wght=4.3,
lambda=lambdaTrue*(1.05))
Fit1<- LKrigFindLambdaAwght( x,Y,LKinfo=LKinfoTest,
verbose=FALSE)
print(Fit1$summary)
set.seed( 122)
M<- 1e3 # nummber of independent spatial replications
N<- 1e2 # number of obs
x<- matrix( runif(2*N ), N,2)
lambdaTrue<- .1^2
#NOTE: true rho is 1.0 dont add fixed function so likelihood is precise.
LKinfoTrue<- LKrigSetup(x,NC=8, nlevel=3, a.wght= 4.2,
alpha=c(1.0,.5,.25), lambda=lambdaTrue,
normalize=FALSE, NC.buffer=2, fixedFunction = NULL)
f<- LKrig.sim( x, LKinfoTrue, M=M)
E<- matrix( rnorm( prod( dim( f))), nrow= nrow( f), ncol=ncol(f) )
Y<- f + sqrt(lambdaTrue)* E
LKinfoTest<- LKinfoUpdate( LKinfoTrue, a.wght=4.3,
lambda=lambdaTrue*(1.05))
tick<- Sys.time()
Fit1<- LKrigFindLambdaAwght( x,Y,LKinfo=LKinfoTest,
verbose=FALSE)
tock<- Sys.time()
print( tock - tick)
print(Fit1$summary)
LKinfoTest
set.seed( 122)
M<- 1e3 # nummber of independent spatial replications
N<- 1e2 # number of obs
x<- matrix( runif(2*N ), N,2)
lambdaTrue<- .1^2
#NOTE: true rho is 1.0 dont add fixed function so likelihood is precise.
LKinfoTrue<- LKrigSetup(x,NC=3, nlevel=3, a.wght= 4.2,
alpha=c(1.0,.5,.25), lambda=lambdaTrue,
normalize=FALSE, NC.buffer=2, fixedFunction = NULL)
f<- LKrig.sim( x, LKinfoTrue, M=M)
E<- matrix( rnorm( prod( dim( f))), nrow= nrow( f), ncol=ncol(f) )
Y<- f + sqrt(lambdaTrue)* E
LKinfoTest<- LKinfoUpdate( LKinfoTrue, a.wght=4.3,
lambda=lambdaTrue*(1.05))
tick<- Sys.time()
Fit1<- LKrigFindLambdaAwght( x,Y,LKinfo=LKinfoTest,
verbose=FALSE)
tock<- Sys.time()
print( tock - tick)
print(Fit1$summary)
M<- 1e3 # nummber of independent spatial replications
N<- 1e2 # number of obs
x<- matrix( runif(2*N ), N,2)
lambdaTrue<- .1^2
#NOTE: true rho is 1.0 dont add fixed function so likelihood is precise.
LKinfoTrue<- LKrigSetup(x,NC=3, nlevel=3, a.wght= 4.2,
alpha=c(1.0,.5,.25), lambda=lambdaTrue,
normalize=FALSE, NC.buffer=2, fixedFunction = NULL)
f<- LKrig.sim( x, LKinfoTrue, M=M)
E<- matrix( rnorm( prod( dim( f))), nrow= nrow( f), ncol=ncol(f) )
Y<- f + sqrt(lambdaTrue)* E
LKinfoTest<- LKinfoUpdate( LKinfoTrue, a.wght=4.3,
lambda=lambdaTrue*(1.05))
tick<- Sys.time()
Fit1<- LKrigFindLambdaAwght( x,Y,LKinfo=LKinfoTest,
verbose=FALSE)
tock<- Sys.time()
print( tock - tick)
print(Fit1$summary)
Fit1$lnLike.eval
library( LatticeKrig)
LatticeKrig
setwd("~/Home/Repositories/LatticeKrig/R")
source('~/Home/Repositories/LatticeKrig/R/LatticeKrig.R', echo=TRUE)
source('~/Home/Repositories/LatticeKrig/R/LatticeKrig.R', echo=TRUE)
help( LKrigFindLambdaAwght)
data(NorthAmericanRainfall)
# rename for less typing
x<- cbind( NorthAmericanRainfall$longitude, NorthAmericanRainfall$latitude)
# total precip in 1/10 mm for JJA
y<- log10(NorthAmericanRainfall$precip)
# cut down the size of this data set so examples run quickly
# examples also work with  the full data set. Also try NC= 100 for a
# nontrivial model.
ind<- x[,1] > -90 & x[,2] < 35 #
x<- x[ind,]
y<- y[ind]
# This is a single level smoother
LKinfo<- LKrigSetup(x,NC=8,nlevel=1, a.wght=4.2, alpha=1.0)
lambdaFit<- LKrigFindLambda( x,y,LKinfo=LKinfo)
lambdaFit$summary
## Not run:
# MLEs for a.wght and lambda:
aWghtFit<- LKrigFindLambdaAwght( x,y,LKinfo=LKinfo)
aWghtFit$summary
out1<- LatticeKrig(x,y)
out1
out2<- LatticeKrig(x,y, findAwght=TRUE)
obj
aWghtFit
names(aWghtFit)
source('~/Home/Repositories/LatticeKrig/R/LatticeKrig.R', echo=TRUE)
out2<- LatticeKrig(x,y, findAwght=TRUE)
source('~/Home/Repositories/LatticeKrig/R/LatticeKrig.R', echo=TRUE)
out2<- LatticeKrig(x,y, findAwght=TRUE)
