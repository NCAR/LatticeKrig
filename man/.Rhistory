Hy<- Htest( truef) + rnorm(N)*.5
y<- Htest(Hy, inv=TRUE)
# check this out
set.panel(2,1)
plot( x, y)
lines( x, truef, col="red")
title("raw data")
plot( x, Hy)
lines( x, Htest(truef), col="red")
title("TBS data")
fit0<- LatticeKrig( x, Hy, LKinfo=LKinfo)
f0<- Htest( fit0$fitted.values, inv=TRUE)
plot( x, f0, type="l", lwd=3)
lines( x, truef, col="magenta")
for( iteration in 1:10 ){
cat( iteration, " ")
yTemp<- (Hy - fit0$fitted.values)
W<- diag( c(dHtest(f0) ) )
PHI<- LKrig.basis( x, LKinfo)
X<- W%*%PHI
U<- W%*%cbind( rep( 1, N), x)
fit1<- LKrig( sDomain, yTemp, U=U, X=X, LKinfo=LKinfo, lambda=2)
update<- predict( fit1, x)
f1<- f0 + update
lines( x, f1, col="red")
fit0<- fit1
}
lines( x, truef, col="blue3")
plot( x, Hy)
lines( x, Htest(truef), col="magenta")
plot( x, Hy)
lines( x, Htest(truef), col="magenta", lwd=3)
lines( x, Htest(f0), col="grey", lwd=3)
plot( x, Hy)
lines( x, Htest(truef), col="magenta", lwd=3)
lines( x, Htest(f0), col="grey", lwd=3)
for( iteration in 1:10 ){
cat( iteration, " ")
yTemp<- (Hy - fit0$fitted.values)
W<- diag( c(dHtest(f0) ) )
PHI<- LKrig.basis( x, LKinfo)
X<- W%*%PHI
U<- W%*%cbind( rep( 1, N), x)
fit1<- LKrig( sDomain, yTemp, U=U, X=X, LKinfo=LKinfo, lambda=2)
update<- predict( fit1, x)
f1<- f0 + update
lines( x, Htest(f1), col="red")
fit0<- fit1
}
# first fit
fit0<- LatticeKrig( x, Hy, LKinfo=LKinfo)
f0<- Htest( fit0$fitted.values, inv=TRUE)
plot( x, f0, type="l", lwd=3)
lines( x, truef, col="magenta")
plot( x, Hy)
lines( x, Htest(truef), col="magenta", lwd=3)
lines( x, Htest(f0), col="grey", lwd=3)
for( iteration in 1:10 ){
cat( iteration, " ")
yTemp<- (Hy - fit0$fitted.values)
W<- diag( c(dHtest(f0) ) )
PHI<- LKrig.basis( x, LKinfo)
X<- W%*%PHI
U<- W%*%cbind( rep( 1, N), x)
fit1<- LatticeKrig( sDomain, yTemp, U=U, X=X, LKinfo=LKinfo, lambda=2)
update<- predict( fit1, x)
f1<- f0 + update
lines( x, Htest(f1), col="red")
fit0<- fit1
}
lines( x, f1, col="black")
plot( x, f1)
plot( x, Htest(f1))
lines( x, truef)
lines( x, Htest(truef))
plot( x, truef)
lines( x, f1)
lines( x, f0)
# check  out data
set.panel(2,1)
plot( x, y)
lines( x, truef, col="red")
title("raw data")
plot( x, Hy)
lines( x, Htest(truef), col="red")
title("TBS data")
source('~/.active-rstudio-document', echo=TRUE)
plot( x, Hy)
lines( x, Htest(truef), col="magenta", lwd=3)
lines( x, Htest(f0), col="grey", lwd=3)
lines( x, Htest(f1), col="black")
fit0<- LatticeKrig( x, Hy, LKinfo=LKinfo)
f0<- Htest( fit0$fitted.values, inv=TRUE)
plot( x, f0)
plot( x, Hy)
lines( x, Htest(truef), col="magenta", lwd=3)
lines( x, Htest(f0), col="grey", lwd=3)
yTemp<- (Hy - fit0$fitted.values)
W<- diag( c(dHtest(f0) ) )
W
diag( W)
PHI<- LKrig.basis( x, LKinfo)
W<- diag( c(dHtest(f0) ) )
X<- W%*%PHI
U<- W%*%cbind( rep( 1, N), x)
fit1<- LatticeKrig( sDomain, yTemp, U=U, X=X, LKinfo=LKinfo)
update<- predict( fit1, x)
plot( x, update)
plot( x, Hy)
lines( x, Htest(truef), col="magenta", lwd=3)
lines( x, Htest(f0), col="grey", lwd=3)
f1<- f0 + update
lines( x, Htest(f1), col="red")
Htest( f1)
lines( x, Htest(f1), col="black")
lines( x, Htest(f0), col="grey", lwd=3)
fit0<- fit1
yTemp<- (Hy - fit0$fitted.values)
W<- diag( c(dHtest(f0) ) )
X<- W%*%PHI
U<- W%*%cbind( rep( 1, N), x)
fit1<- LatticeKrig( sDomain, yTemp, U=U, X=X, LKinfo=LKinfo)
update<- predict( fit1, x)
f1<- f0 + update
lines( x, Htest(f1), col="black")
plot( x, yTemp)
yTemp<- (Hy - fit0$fitted.values)
plot( x, yTemp)
plot( x, fit0$fitted.values)
fit0<- LatticeKrig( x, Hy, LKinfo=LKinfo)
f0<- Htest( fit0$fitted.values, inv=TRUE)
plot( x, Hy)
lines( x, Htest(truef), col="magenta", lwd=3)
lines( x, Htest(f0), col="grey", lwd=3)
PHI<- LKrig.basis( x, LKinfo)
fNew<- f0
yTemp<- (Hy - Htest(fNew))
W<- diag( c(dHtest(fNew) ) )
X<- W%*%PHI
U<- W%*%cbind( rep( 1, N), x)
fit1<- LatticeKrig( sDomain, yTemp, U=U, X=X, LKinfo=LKinfo)
update<- predict( fit1, x)
f1<- fNew + update
lines( x, Htest(f1), col="black")
fNew<- f1
yTemp<- (Hy - Htest(fNew))
W<- diag( c(dHtest(fNew) ) )
X<- W%*%PHI
U<- W%*%cbind( rep( 1, N), x)
fit1<- LatticeKrig( sDomain, yTemp, U=U, X=X, LKinfo=LKinfo)
update<- predict( fit1, x)
f1<- fNew + update
lines( x, Htest(f1), col="black")
plot( x, yTemp)
fit0<- LatticeKrig( x, Hy, LKinfo=LKinfo, lambda=2)
f0<- Htest( fit0$fitted.values, inv=TRUE)
quartz()
plot( x, Hy)
lines( x, Htest(truef), col="magenta", lwd=3)
lines( x, Htest(f0), col="grey", lwd=3)
PHI<- LKrig.basis( x, LKinfo)
fNew<- f0
for( iteration in 1:10 ){
cat( iteration, " ")
yTemp<- (Hy - Htest(fNew))
W<- diag( c(dHtest(fNew) ) )
X<- W%*%PHI
U<- W%*%cbind( rep( 1, N), x)
fit1<- LatticeKrig( sDomain, yTemp, U=U, X=X, LKinfo=LKinfo)
update<- predict( fit1, x)
f1<- fNew + update
lines( x, Htest(f1), col="black")
fNew<- f1
}
lines( x, Htest(f1), col="black")
f0<-  rep( Htest( mean( Hy), inv=TRUE), N)
plot( x, Hy)
lines( x, Htest(truef), col="magenta", lwd=3)
lines( x, Htest(f0), col="grey", lwd=3)
PHI<- LKrig.basis( x, LKinfo)
fNew<- f0
for( iteration in 1:10 ){
cat( iteration, " ")
yTemp<- (Hy - Htest(fNew))
W<- diag( c(dHtest(fNew) ) )
X<- W%*%PHI
U<- W%*%cbind( rep( 1, N), x)
fit1<- LatticeKrig( sDomain, yTemp, U=U, X=X, LKinfo=LKinfo)
update<- predict( fit1, x)
f1<- fNew + update
lines( x, Htest(f1), col="black")
fNew<- f1
}
lines( x, Htest(f1), col="black")
Htest<- function( u, inv=FALSE){
if( !inv){ ifelse(u>1e-5, log(u), log(1e-5) }
else{exp(u) }
}
dHtest<- function( u){
1/u
}
# synthetic data
set.seed( 222)
Hy<- Htest( truef) + rnorm(N)*.5
y<- Htest(Hy, inv=TRUE)
# check  out data
set.panel(2,1)
plot( x, y)
lines( x, truef, col="red")
title("raw data")
plot( x, Hy)
lines( x, Htest(truef), col="red")
title("TBS data")
# first fit
fit0<- LatticeKrig( x, Hy, LKinfo=LKinfo, lambda=2)
f0<- Htest( fit0$fitted.values, inv=TRUE)
f0<-  rep( Htest( mean( Hy), inv=TRUE), N)
quartz()
plot( x, Hy)
lines( x, Htest(truef), col="magenta", lwd=3)
lines( x, Htest(f0), col="grey", lwd=3)
PHI<- LKrig.basis( x, LKinfo)
fNew<- f0
for( iteration in 1:10 ){
cat( iteration, " ")
yTemp<- (Hy - Htest(fNew))
W<- diag( c(dHtest(fNew) ) )
X<- W%*%PHI
U<- W%*%cbind( rep( 1, N), x)
fit1<- LatticeKrig( sDomain, yTemp, U=U, X=X, LKinfo=LKinfo)
update<- predict( fit1, x)
f1<- fNew + update
lines( x, Htest(f1), col="black")
fNew<- f1
}
lines( x, Htest(f1), col="black")
Htest<- function( u, inv=FALSE){
if( !inv){ ifelse(u>1e-5, log(u), log(1e-5) ) }
else{exp(u) }
}
dHtest<- function( u){
1/u
}
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
library( LatticeKrig)
help( "LatticeKrig")
help( "LKrig")
data(ozone2)
x<- ozone2$lon.lat
y<- ozone2$y[16,]
good<- !is.na(y)
x<- x[good,]
y<- y[good]
LKinfo<- LKrigSetup(x, a.wght=4.5, nlevel=3, nu=1, NC=4, lambda=.01)
A<- NNDist
A$ra<- exp(-NNDist$ra)
# A is a weight matrix based on neighbors close by and
# in spind sparse matrix format
# now convert to spam format
A<- spind2spam(A)
NNDist<- LKDist(x,x, delta=1.5)
A<- NNDist
A$ra<- exp(-NNDist$ra)
# A is a weight matrix based on neighbors close by and
# in spind sparse matrix format
# now convert to spam format
A<- spind2spam(A)
TMatrix <- get(LKinfo$fixedFunction)(x = x)
# Tmatrix is a 3 column matrix of constant and the two spatial coordinates
#  i.e. a linear function of the spatial variables
PHI<- LKrig.basis(x, LKinfo)
X<-  A%*% PHI
U<-  A%*%TMatrix
yIndirect<- A%*%y
out0<- LatticeKrig(x,y, LKinfo=LKinfo)
out1<- LatticeKrig(x,yIndirect, U=U, X=X, LKinfo=LKinfo)
surface( out1)
surface( out0)
library(fields)
Wendland.beta
help( "Wendland.beta")
Wendland.beta(2,2)
Wendland2.2
35/3
Wendland
dt<- seq( 0,1.5,, 200)
y<- Wendland( dt, k=2, dimension=2)
plot( dt, y, type="l")
y<- Wendland( dt, k=4, dimension=2)
lines( dt, y)
y<- Wendland( dt, k=4, dimension=3)
lines( dt, y)
y<- Wendland( dt, k=4, dimension=5)
lines( dt, y)
y<- Wendland( dt, k=4, dimension=1)
lines( dt, y)
y<- Wendland( dt, k=41, dimension=1)
y<- Wendland( dt, k=1, dimension=1)
lines( dt, y)
help( "Wendland")
wendland.eval
version()
Version()
library( LatticeKrig)
5.125*2.54
4.25*2.54
ar.sim<-arima.sim(model=list(ar=c(.9,-.2)),n=100)
plot( ar.sim)
plot( ar.sim, type="p")
ar.sim<-arima.sim(model=list(ar=c(.2,-.2)),n=1000)
plot( ar.sim, type="h")
plot( ar.sim[1:10], type="h")
library( LatticeKrig)
source('~/Dropbox/Home/Repositories/LatticeKrig/tests/LKrig.precision.test.R', echo=TRUE)
test.for.zero.flag<- 1
# test building MRF
mx<- rbind(c(5,6))
m<- mx[1,1]* mx[1,2]
temp<- matrix( 1:m, mx[1,1],mx[1,2])
m1<- mx[1,1]
m2<- mx[1,2]
I.c<- temp
I.B<-  cbind(      rep(NA,m1),           temp[,1:(m2-1)])
I.T<-  cbind(       temp[,2:m2],        rep(NA,m1))
I.L<-  rbind(     rep(NA , m2), temp[ 1:(m1-1),] )
I.R<-  rbind(  temp[2:m1 , ],          rep( NA, m2))
Bi<- rep( 1:30, 5)
Bj<- cbind( c(I.c), c(I.T), c(I.B), c( I.L), c(I.R))
atest<- matrix( (1:m)*5, m1,m2)
values<- cbind( c(atest), rep(-1,m),rep(-1,m),rep(-1,m),rep(-1,m) )
good<- !is.na(c(Bj))
Bi<- Bi[good]
Bj<- Bj[good]
values<- c(values)[c(good)]
LKinfo<- LKrigSetup(  cbind( c( 1,5), c( 1,6)), NC=6, a.wght=matrix(atest, 5,6), nlevel=1, alpha=1, NC.buffer=0)
obj<- LKrigSAR( LKinfo, Level=1)
test.for.zero( cbind( Bi,Bj), obj$ind, tag="MRF index")
test.for.zero( values, obj$ra, tag="MRF value")
#
LKinfo<- LKrigSetup(  cbind( c( 1,5), c( 1,6)), NC=6, a.wght=matrix(atest, 5,6),alpha=1, nlevel=1, NC.buffer=0)
obj<- LKrigSAR( LKinfo, Level=1)
obj2<-spind2full( obj)
test2<- matrix( obj2[8,], 5,6)
test0<- matrix( 0, 5,6)
test0[3,2]<- 5*8
test0[2,2]<- test0[3,1]<- test0[4,2]<- test0[3,3] <- -1
test.for.zero( test2, test0, tag="MRF weight placement")
set.seed(123)
x1<- cbind( runif( 10), runif(10))
LKinfo<- LKrigSetup( cbind( c( -1,1), c( -1,1) ),
nlevel=3, NC=4, a.wght=c(5,6,7), alpha=c(6,6,6) )
X<- LKrig.basis(x1, LKinfo)
X<- as.matrix(X)
# check on normalization to unit variance at each level
Q<- LKrig.precision( LKinfo)
Q<- as.matrix( Q)
look<- (X)%*% solve( Q) %*%t(X)
marginal.var<- sum(unlist(LKinfo$alpha))
test.for.zero( diag(look), rep( marginal.var,10),
tag="normalization to unit variance at each level",
tol=5e-7)
look2<- LKrig.cov( x1, LKinfo= LKinfo, marginal=TRUE)
test.for.zero( look2, rep(marginal.var,10) ,
tag="normalization based on logic in LKrig.cov",
tol=5e-7)
# check full covariance matrix
look3<- LKrig.cov( x1, x1,LKinfo= LKinfo)
test.for.zero( look3, look, tag="full covariance from matrix expressions")
# Now test w/o normalization
LKinfo$normalize<- FALSE
X<- LKrig.basis(x1, LKinfo)
X<- as.matrix(X)
# check on normalization to unit variance at each level
Q<- LKrig.precision( LKinfo)
Q<- as.matrix( Q)
look<- (X)%*% solve( Q) %*%t(X)
look3<- LKrig.cov( x1, x1,LKinfo= LKinfo)
test.for.zero( look3, look,
tag="full covariance from matrix expressions w/o normalization")
#
LKinfo<- LKrigSetup( cbind( c( -1,1), c( -1,1) ), nlevel=3, NC=5,
a.wght=c(5,6,7), alpha=c(4,2,1), NC.buffer=0)
set.seed(123)
x1<- cbind( runif( 10), runif(10))
x2<- cbind(0,0)
comp<- matrix( NA,10, 3)
for ( l in 1:3){
LKinfo.temp<- LKrigSetup( cbind( c( -1,1), c( -1,1) ), nlevel=1, NC=LKinfo$latticeInfo$mx[l],
a.wght=c(5,6,7)[l], alpha=1.0, NC.buffer=0)
comp[,l]<- LKrig.cov(x1,x2,LKinfo.temp )
}
look1<- comp%*%c(unlist( LKinfo$alpha))
look3<- LKrig.cov( x1, x2, LKinfo= LKinfo)
test.for.zero( look1, look3, tag="comp normalized cov and LKrig.cov")
#
LKinfo<- LKrigSetup( cbind( c( -1,1), c( -1,1) ), nlevel=1, NC=5,
a.wght=4.5,
alpha=1)
a.wght<-  list( matrix(4 + (1:LKinfo$latticeInfo$m)*.1, LKinfo$latticeInfo$mx[1,2], LKinfo$latticeInfo$mx[1,2]))
LKinfo<- LKrigSetup( cbind( c( -1,1), c( -1,1) ), nlevel=1, NC=5,
a.wght=a.wght,
alpha=1)
look<- LKrig.precision( LKinfo=LKinfo, return.B=TRUE)
look2<- as.matrix( look)
test.for.zero( diag( look2), a.wght[[1]], tag="spatial a.wght 1 level")
# three levels
LKinfo0 <- LKrigSetup( cbind( c( -1,1), c( -1,1) ), nlevel=3, NC=4,
a.wght=c(5,5,5),
alpha=c(1,1,1), edge=FALSE)
N<- LKinfo0$latticeInfo$mx[,1]*LKinfo0$latticeInfo$mx[,2]
a.wght<-  list(
matrix(4 +  (1:N[1])*.1, LKinfo0$latticeInfo$mx[1,1], LKinfo0$latticeInfo$mx[1,2] ),
matrix(4 +  (1:N[2])*.1, LKinfo0$latticeInfo$mx[2,1], LKinfo0$latticeInfo$mx[2,2] ),
matrix(4 +  (1:N[3])*.1, LKinfo0$latticeInfo$mx[3,1], LKinfo0$latticeInfo$mx[3,2] )
)
LKinfo <- LKrigSetup( cbind( c( -1,1), c( -1,1) ), nlevel=3, NC=4,
a.wght=a.wght,
alpha=c(1,1,1), edge=FALSE)
look<- LKrig.precision( LKinfo=LKinfo, return.B=TRUE)
look2<- as.matrix( look)
test.for.zero( diag( look2), unlist(a.wght), tag="spatial a.wght 3 levels")
#
LKinfo0 <- LKrigSetup( cbind( c( -1,1), c( -1,1) ), nlevel=3, NC=4,NC.buffer=3,
a.wght=c(5,5,5),
alpha=c(1,1,1), edge=FALSE)
N<- LKinfo0$latticeInfo$mx[,1]*LKinfo0$latticeInfo$mx[,2]
alpha<-  list(  (1:N[1])*.1, (1:N[2])*.1, (1:N[3])*.1)
LKinfo <- LKrigSetup( cbind( c( -1,1), c( -1,1) ), nlevel=3, NC=4, NC.buffer=3,
a.wght=5,
alpha=alpha, edge=FALSE)
look<- LKrig.precision( LKinfo, return.B=TRUE)
N
source('~/Dropbox/Home/Repositories/LatticeKrig/tests/LKrig.precision.test.R', echo=TRUE)
options( echo=TRUE)
predict.Krig
interp.surface
gridList<- list( x = seq( -1,1,,20), y = seq(-1,1,,20) )
xPoints<- make.surface.grid( gridList)
alphaTemp<-  cbind(
ifelse( xPoints[,1]<0, 1, 0 ),
ifelse( xPoints[,1]<0, .5, 1 ),
ifelse( xPoints[,1]<0, .25, .5 )
)
alphaTemp <- alphaTemp/rowSums(alphaTemp)
alphaTemp <- alphaTemp/rowSums(alphaTemp)
alphaObject<- list()
for( k in 1:3){
hold<- as.surface( xPoints, alphaTemp[,k])
class( hold)<- "surfaceGrid"
alphaObject<- c( alphaObject, list( hold))
}
predict.surfaceGrid<- function(object,x){
interp.surface( object, x)
}
gridList<- list( x = seq( -1,1,,10), y = seq(-1,1,,15) )
xPoints<- make.surface.grid( gridList)
alphaTemp<-  cbind(
ifelse( xPoints[,1]<0, 1, 0 ),
ifelse( xPoints[,1]<0, .5, 1 ),
ifelse( xPoints[,1]<0, .25, .5 )
)
alphaTemp <- alphaTemp/rowSums(alphaTemp)
alphaObject<- list()
for( k in 1:3){
hold<- as.surface( xPoints, alphaTemp[,k])
class( hold)<- "surfaceGrid"
alphaObject<- c( alphaObject, list( hold))
}
predict( alphaObject[[1]], xg)
predict( alphaObject[[1]], xPoints)
predict.surfaceGrid<- function(object,x){
interp.surface( object, x)
}
# the alpha's are chosen to be  proportional to c( 1,.5,.25) for the
# x[,1] < 0 and  proportional to c( 0,1,.5) when x[,1] >= 0
# To keep things identified the alpha weights at any location are normalized to # sum to 1.
# coarse grid to define the alpha's
gridList<- list( x = seq( -1,1,,10), y = seq(-1,1,,15) )
xPoints<- make.surface.grid( gridList)
# create a 3 column matrix with alpha weights at each grid point
alphaTemp<-  cbind(
ifelse( xPoints[,1]<0, 1, 0 ),
ifelse( xPoints[,1]<0, .5, 1 ),
ifelse( xPoints[,1]<0, .25, .5 )
)
alphaTemp <- alphaTemp/rowSums(alphaTemp)
alphaObject<- list()
for( k in 1:3){
# covert from a vector to the image/list format  $x $y $z
hold<- as.surface( xPoints, alphaTemp[,k])
# give this object a class so that predict.surfaceGrid is called.
class( hold)<- "surfaceGrid"
# accumulate these objects in a list (yes this is a "list of lists")
alphaObject<- c( alphaObject, list( hold))
}
fineGrid<- make.surface.grid(list( x=seq( -1,1,,100), y= x=seq( -1,1,,100)))
fineGrid<- make.surface.grid(list( x=seq( -1,1,,100), y=seq( -1,1,,100)))
image.plot(as.surface( fineGrid, predict( alphaObject[[2]]),fineGrid ) )
alphaObject[[2]])
alphaObject[[2]]
fineGrid
look<_ predict( alphaObject[[2]]), fineGrid )
look<- predict( alphaObject[[2]]), fineGrid )
look<- predict( alphaObject[[2]], fineGrid )
image.plot(as.surface( fineGrid, predict( alphaObject[[2]], fineGrid ) ) )
source('~/Dropbox/Home/Repositories/LatticeKrig/tests/LKrig.test.R', echo=TRUE)
library( LatticeKrig)
source('~/Dropbox/Home/Repositories/LatticeKrig/tests/LKrig.test.R', echo=TRUE)
source('~/Dropbox/Home/Repositories/LatticeKrig/tests/LKrig.test.R', echo=TRUE)
source('~/Dropbox/Home/Repositories/LatticeKrig/tests/LKrig.test.R', echo=TRUE)
setwd("~/Dropbox/Home/Repositories/LatticeKrig/man")
