# Appendix B: Comparison with kriging from fields package

In this section we will compare the kriging done in LatticeKrig with ordinary kriging, such as the kriging done in fields. The chief difference is that LatticeKrig assumes a particular covariance function that leads to a sparse precision matrix (the precision matrix is the inverse of the covariance matrix). However, when we do ordinary kriging with this particular covariance function, we will see that the results come out the same for both algorithms, though the ordinary kriging uses dense matrix operations so it takes much longer with large data. To investigate this, we will use \ttt{LKrig} (the function that does the computation in \ttt{LatticeKrig}) and \ttt{mKrig} to compute models for the data. To make sure the parameters match up, we use an \ttt{LKinfo} object to store the parameters for the kriging. 

```{r FieldsComparison}
data(ozone2)  
x <- ozone2$lon.lat
y <- ozone2$y[16,]
# Find location that are not 'NA'.
# (LKrig is not set up to handle missing observations.)
good <- !is.na(y)
x<- x[good,]
y<- y[good]
lambda <-  1.5
# The covariance "parameters" are all in the list LKinfo
# to create this special list outside of a call to LKrig use
testInfo <- LKrigSetup(x, NC=16, nlevel=1, alpha=1.0, a.wght=5)
obj1 <- LKrig(x, y, lambda=lambda, iseed=122, LKinfo = testInfo)

# this call to mKrig should be identical to the LKrig results
# because it uses the LKrig.cov covariance with all the right parameters.
obj2 <- mKrig(x, y, lambda=lambda, m=2, cov.function="LKrig.cov",
              cov.args=list( LKinfo=testInfo), iseed=122)
# compare the two results this is also an
# example of how tests are automated in fields
# set flag to have tests print results
test.for.zero.flag<- TRUE
test.for.zero(obj1$fitted.values, obj2$fitted.values,
               tag="comparing predicted values LKrig and mKrig")
# compare standard errors. 
se1 <- predictSE.LKrig(obj1)
se2 <- predictSE.mKrig(obj2)
test.for.zero(se1, se2, tag="comparing standard errors for LKrig and mKrig")
```

As we can see, these two kriging fits produce identical predicted values and standard errors, as we would expect. To make \ttt{mKrig} use the same covariance function as \ttt{LKrig}, we set the parameter \ttt{cov.function="LKrig.cov"}. The \ttt{LKrig.cov} function computes the covariance between the lattice points and the data points in such a way that the precision matrix will be sparse and have a certain form. We can then produce the precision matrix directly instead of inverting the covariance matrix, which is one of the reasons that \ttt{LKrig} is much faster than \ttt{mKrig}.