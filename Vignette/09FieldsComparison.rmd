# Comparison with fields package

In this section we will compare the kriging done in LatticeKrig with ordinary kriging, such as the kriging done in fields. The chief difference is that LatticeKrig assumes a particular covariance function that leads to a sparse precision matrix (the precision matrix is the inverse of the covariance matrix). However, when we do ordinary kriging with this particular covariance function, we will see that the results come out the same for both algorithms, though the ordinary kriging uses dense matrix operations so it takes much longer with large data.

```{r FieldsComparison}
data(ozone2)  
x<-ozone2$lon.lat
y<- ozone2$y[16,]
# Find location that are not 'NA'.
# (LKrig is not set up to handle missing observations.)
good <-  !is.na( y)
x<- x[good,]
y<- y[good]
a.wght<- 5
lambda <-  1.5
obj1<- LKrig( x,y,NC=16,nlevel=1, alpha=1,  lambda=lambda, a.wght=5,
              NtrA=20,iseed=122)

# in both calls iseed is set the same so we can compare 
# Monte Carlo estimates of effective degrees of freedom
obj1$trA.est
# The covariance "parameters" are all in the list LKinfo
# to create this special list outside of a call to LKrig use
LKinfo.test <- LKrigSetup( x, NC=16, nlevel=1, alpha=1.0,  a.wght=5)

# this call to mKrig should be identical to the LKrig results
# because it uses the LKrig.cov covariance with all the right parameters.
obj2<- mKrig( x,y, lambda=lambda, m=2, cov.function="LKrig.cov",
              cov.args=list( LKinfo=LKinfo.test), NtrA=20, iseed=122)
# compare the two results this is also an
# example of how tests are automated in fields
# set flag to have tests print results
test.for.zero.flag<- TRUE
test.for.zero( obj1$fitted.values, obj2$fitted.values,
               tag="comparing predicted values LKrig and mKrig")
# compare standard errors. 
se1<- predictSE.LKrig( obj1)
se2<- predictSE.mKrig(obj2)
test.for.zero( se1, se2,
               tag="comparing standard errors for LKrig and mKrig")
```