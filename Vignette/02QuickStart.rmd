# Quick Start Guide

In this section, we will lay out the bare essentials of the package as a quick introduction. To fit a surface and interpolate data using \ttt{LatticeKrig}, the minimum required arguments are the measurement locations (formatted in a matrix where each row is one location) and measurement values. However, we highly recommend using some of the optional parameters to customize the model to your specific data problem. hCalling the \ttt{LatticeKrig} function and passing in the locations and values will produce an \ttt{LKrig} object that contains all the information needed to predict the variable at any location. For a simple, 1-dimensional example, we will take our locations to be 50 randomly spaced points on the interval $[-6, 6]$, and our variable measurements to be the values of $\sin(x)$ at these locations. 

```{r QuickStart1D}
set.seed(223)
locations <- runif(50, min=-6, max=6)
observations <- sin(locations) + rnorm(50, sd = 1e-2)
kFit <- LatticeKrig(locations, observations)
kFit
```
Now, we'll make a plot of the original 50 data points and the true function ($\sin(x)$) and the \ttt{LatticeKrig} fit at 200 equally spaced points to compare them.
```{r QuickStart1DPlot}
xGrid <- seq(-2*pi, 2*pi, len=200)
plot(locations, observations, main="1-Dimensional LatticeKrig Example", 
     xlab="Location", ylab="Measured Value")
lines(xGrid, sin(xGrid), col='blue')
lines(xGrid, predict(kFit, xGrid), col='red')
```

We can see that \ttt{LatticeKrig} takes in the data points (shown above in black) and produces a prediction over the whole interval (in red) that matches the true function (in blue) rather closely. For another, more practical example, we will predict the average spring temperature for locations throughout Colorado. Using the data set \ttt{COmonthlyMet}, we can make a surface showing our predictions over a range of longitudes and latitudes, and use the \ttt{US} function to draw in the USA state borders to show where Colorado is. Notice that \ttt{LatticeKrig} will automatically discard any data points with missing values (NAs) if needed.

```{r QuickStart2D}
data(COmonthlyMet)
locations <- CO.loc
observations <- CO.tmean.MAM.climate
kFit <- LatticeKrig(locations, observations)
surface(kFit, main = "2-Dimensional LatticeKrig Example",
        xlab="Longitude", ylab="Latitude")
US(add=TRUE, col='black', lwd=4)
```

This plot is nice, but we can do better. We can see that the coldest temperatures are in the Rocky Mountains, which is unsurprising. Thus, we might expect that we will get a more accurate fit by having \ttt{LatticeKrig} account for the elevation at each location as well. Another way we can improve the plot is by increasing its resolution - the current plot is somewhat pixelated. We can tell the \ttt{surface} function to evaluate the surface at more points by using the \ttt{nx} and \ttt{ny} arguments, which will take longer to compute but produces a nicer looking, more detailed plot. Finally, we can also have \ttt{surface} extend the computation all the way to the corners of the window by using the \ttt{extrap} argument; by default it doesn't extrapolate outside of the existing data, since the \ttt{LatticeKrig} fitting method isn't designed to extrapolate and so the expected error increases dramatically when predicting outside of the given data. However, extending the plot to the corners will make it look nicer.

```{r QuickStart2DImproved}
data(COmonthlyMet)
locations <- CO.loc
observations <- CO.tmean.MAM.climate
elevations <- CO.elev
kFit <- LatticeKrig(locations, observations, Z=cbind(elevations))
prediction <- predictSurface(kFit, grid.list = CO.Grid, ZGrid = CO.elevGrid,
                             nx = 200, ny = 150, extrap = TRUE)
surface(prediction, main = "Improved 2-Dimensional LatticeKrig Example", 
        xlab="Longitude", ylab="Latitude")
US(add=TRUE, col='black', lwd=4)
```
