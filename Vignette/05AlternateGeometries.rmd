# Kriging in Different Geometries

By default, \ttt{LatticeKrig} will interpret the location data it receives as points in $n$-dimensional Euclidean space, and calculate the distance accordingly. However, this package also supports distance measurements on a sphere, interpreting the given locations as latitude and longitude on Earth. There are also other options for non-Euclidean geometries: a cylinder, which uses 3 dimensional cylindrical coordinates, and a ring, which takes 2 dimensional cylindrical coordinates (z and $\theta$, with fixed radius). You can change the geometry used by passing it into the \ttt{LKGeometry} parameter of an \ttt{LKinfo} object. These are the names that \ttt{LKinfo} recognizes:

* \ttt{LKInterval}: 1 dimensional Euclidean space
* \ttt{LKRectangle}: 2 dimensional Euclidean space
* \ttt{LKBox}: 3 dimensional Euclidean space
* \ttt{LKSphere}: 2 dimensional spherical coordinates
* \ttt{LKCylinder}: 3 dimensional cylindrical coordinates
* \ttt{LKRing}: 2 dimensional cylindrical coordinates

By default, \ttt{LKinfo} will use either \ttt{LKInterval}, \ttt{LKRectangle}, or \ttt{LKBox}, depending on the number of dimensions in the given location data. When using the \ttt{LKSphere} geometry, there are also different ways of measuring distance, which you can set using the \ttt{distance.type} parameter of the \ttt{LKinfo} object - the default is \ttt{GreatCircle}, which measures the shortest distance over the surface of the sphere, or you can use \ttt{Chordal} to measure the shortest straight-line distance, going under the surface of the sphere.

## Working with spherical coordinates

For an example of fitting data taken on the globe using spherical geometry instead of rectangular, we will create some sample data at the equator, rotate it up to near the north pole, and compare the models computed on the \ttt{LKRectangle} geometry and \ttt{LKSphere} geometry. We compute a kriging fit for the original data and the rotated data using the rectangular geometry and the spherical geometry, and print out the sum of squared errors as a measurement of how accurately the different fits match the data.

```{r SphereExampleDataCreation}
length = 30
gridAngle = 40
grid <- list(x = seq(-gridAngle/2, gridAngle/2, len=length)-5,
             y = seq(-gridAngle/4, gridAngle/4, len=length/2));
dataLocations <- make.surface.grid(grid)
dataValues <- sin(2*pi/gridAngle * (5+dataLocations[,1])) *sin(2*pi/gridAngle * dataLocations[,2])

#rotating the locations up 85 degrees to the north pole
theta = 85 * (pi/180)
cosineGrid <- directionCosines(dataLocations)
rotationMatrix <- cbind(c(cos(theta), 0, sin(theta)), c(0,1,0), c(-sin(theta), 0, cos(theta)))
newCosineGrid <- t(rotationMatrix %*% t(cosineGrid))
newLocations <- toSphere(newCosineGrid)
#plot the data at the equator and at the north pole in rectangular coordinates
#note the significant distortion at the north pole
quilt.plot(dataLocations, dataValues)
world(add=TRUE, col="black", lwd=1)
quilt.plot(newLocations, dataValues)
world(add=TRUE, col="black", lwd=1)
```

<!-- Remember that, even though the second plot looks radically different from the first, they are both plots of the same data over equally spaced data points - the distortions in the second map are caused by the map projection failing near the pole. -->

Now, we will use \ttt{LatticeKrig} to approximate the surface in both rectangular and spherical geometries.

```{r SphereExampleRectangleComparison}
kFit1 <- LatticeKrig(dataLocations, dataValues)
surface(kFit1, main="Equator Surface Prediction Using Rectangular Kriging")
sum(kFit1$residuals^2)

kFit2 <- LatticeKrig(newLocations, dataValues)
surface(kFit2, main="Polar Surface Prediction Using Rectangular Kriging")
sum(kFit2$residuals^2)
```

```{r SphereExample}
info1 <- LKrigSetup(dataLocations, nlevel = 2, startingLevel = 6, alpha = c(0.8, 0.2)
                   , a.wght = 1.01, LKGeometry = "LKSphere")
kFit1 <- LatticeKrig(dataLocations, dataValues, LKinfo = info1)
surface(kFit1, main="Equator Surface Prediction Using Spherical Kriging")
sum(kFit1$residuals^2)

info2 <- LKrigSetup(newLocations, nlevel = 2, startingLevel = 6, alpha = c(0.8, 0.2)
                   , a.wght = 1.01, LKGeometry = "LKSphere")
kFit2 <- LatticeKrig(newLocations, dataValues, LKinfo = info2)
surface(kFit2, main="Polar Surface Prediction Using Spherical Kriging")
sum(kFit2$residuals^2)
```

As we can see, the rectangular fit fails badly on the data that has been rotated up to the north pole, while the corresponding spherical model matches the data very well.